<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chapters Viewer & PDF Converter</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
body { font-family: Arial, sans-serif; margin:0; padding:0; background:#121212; color:#fff; text-align:center; }
.container { display:flex; flex-direction:column; align-items:center; width:100%; }
img { max-width:100%; height:auto; margin-bottom:5px; box-shadow:0 2px 4px rgba(0,0,0,0.8); }
h1 { margin:20px; font-size:24px; color:#f5f5f5; }
h2.chapter-title { margin:30px 0 15px; font-size:20px; color:#ffcc00; }
input,button { margin:8px; padding:10px; font-size:16px; border-radius:5px; border:none; }
input { width:80%; max-width:400px; }
button { background:#ff4081; color:white; cursor:pointer; }
button:hover { background:#e91e63; }
.chapter-form { margin-bottom:15px; }
#status { margin-top:10px; color:#00e676; }
#errors { margin-top:10px; color:#ff5252; white-space:pre-wrap; }
</style>
</head>
<body>
<h1>Chapters Viewer</h1>
<div class="chapter-form">
  <input type="text" id="baseUrl" placeholder="Base URL (link of the image)" required><br>
  <input type="text" id="startPage" placeholder="Start Page (e.g., 001)" value="1"><br>
  <input type="text" id="endPage" placeholder="End Page (e.g., 050)" required><br>
  <button onclick="loadChapter()">Load Chapter</button>
</div>
<button onclick="downloadPDF()">Download All as PDF</button>

<p id="status"></p>
<p id="errors"></p>
<div class="container" id="imageContainer">
  <h2>Enter details and click 'Load Chapter'</h2>
</div>

<script>
let imageElements = [];
let chapterCounter = 0;

async function loadChapter() {
  const container = document.getElementById('imageContainer');
  const status = document.getElementById('status');
  const errors = document.getElementById('errors');
  errors.textContent = "";
  status.textContent = "";

  let baseUrl = document.getElementById('baseUrl').value.trim();
  if(!baseUrl.endsWith("/")) baseUrl += "/";

  const startPageInput = document.getElementById('startPage').value.trim();
  const endPageInput = document.getElementById('endPage').value.trim();
  const startPage = parseInt(startPageInput);
  const endPage = parseInt(endPageInput);
  const formats = ["jpg","jpeg","png","webp"];

  if(!baseUrl || isNaN(startPage) || isNaN(endPage) || endPage < startPage) {
    alert("Please enter a valid Base URL and Page Range.");
    return;
  }

  chapterCounter++;
  const chapterName = `Chapter ${chapterCounter}`;
  const heading = document.createElement("h2");
  heading.className = "chapter-title";
  heading.textContent = chapterName;
  container.appendChild(heading);

  let detectedFormat = null;
  let detectedPadLength = null;

  // function to generate padding options
  const getPaddedNumbers = page => [String(page), page.toString().padStart(2,"0"), page.toString().padStart(3,"0"), page.toString().padStart(4,"0")];

  for(let page = startPage; page <= endPage; page++){
    status.textContent = `Loading page ${page}...`;
    let loaded = false;
    let paddedNumbers = [];

    // if format detected, use fixed padding
    if(detectedFormat && detectedPadLength){
      paddedNumbers = [page.toString().padStart(detectedPadLength,"0")];
    } else {
      paddedNumbers = getPaddedNumbers(page);
    }

    for(let padded of paddedNumbers){
      for(let format of formats){
        // if already detected, only use it
        if(detectedFormat && format !== detectedFormat) continue;

        const url = `${baseUrl}${padded}.${format}`;
        if(await checkImageExists(url)){
          const img = document.createElement('img');
          img.crossOrigin = "Anonymous";
          img.alt = `${chapterName} - Page ${padded}`;
          img.src = url;
          container.appendChild(img);
          imageElements.push({chapter:chapterName, src:url});
          loaded = true;

          // remember detected format & padding for next pages
          if(!detectedFormat){
            detectedFormat = format;
            detectedPadLength = padded.length;
          }

          break;
        }
      }
      if(loaded) break;
    }

    if(!loaded){
      const msg = `Error loading page ${page}`;
      console.warn(msg);
      errors.textContent += msg + "\n";
    }
  }

  status.textContent = `✅ Finished loading chapter ${chapterName}`;
}

function checkImageExists(url){
  return new Promise(resolve=>{
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.src = url + "?t=" + new Date().getTime();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
  });
}

async function downloadPDF(){
  if(imageElements.length === 0){ alert("No chapters loaded."); return; }
  const status = document.getElementById('status');
  status.textContent = "Generating PDF...";
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF('p','mm','a4');
  const pageWidth = 210, pageHeight = 297;
  let currentChapter = "";

  for(let i=0;i<imageElements.length;i++){
    const {chapter, src} = imageElements[i];
    if(chapter !== currentChapter){
      if(i>0) pdf.addPage();
      pdf.setFontSize(20);
      pdf.text(chapter,10,20);
      currentChapter = chapter;
      pdf.addPage();
    }
    const img = await loadImage(src);
    const ratio = img.width/img.height;
    let imgWidth = pageWidth;
    let imgHeight = imgWidth/ratio;
    if(imgHeight>pageHeight){ imgHeight = pageHeight; imgWidth=imgHeight*ratio; }
    const x = (pageWidth-imgWidth)/2;
    const y = (pageHeight-imgHeight)/2;
    pdf.addImage(img,'JPEG',x,y,imgWidth,imgHeight);
    if(i<imageElements.length-1) pdf.addPage();
    status.textContent = `Processing ${i+1} of ${imageElements.length} pages...`;
  }
  pdf.save("Chapters.pdf");
  status.textContent = "✅ PDF Downloaded!";
}

function loadImage(url){
  return new Promise(resolve=>{
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = ()=>resolve(img);
    img.src = url;
  });
}
</script>
</body>
</html>
